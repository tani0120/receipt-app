# ADR-001: 型安全マッピング戦略の採用

**ステータス**: 承認済み  
**決定日**: 2026-01-14  
**決定者**: 司令官  
**関連**: Phase 6 完了後の開発方針

---

## 背景

### 問題の発端

Phase 6完了後、16件のJudgment UseCaseが昇格したが、実装方法に関する根本的な課題が浮上：

1. **手動ハードコード（Lv.1）の失敗**
   - Vueファイルに直接プロパティ名を手書き
   - タイポによる不整合が頻発
   - Zodを修正してもUIに反映されない

2. **開発の迷走リスク**
   - OCRロジックと掃き出しフォーマットの組み合わせが複数存在
   - どのロジックがどの形式に対応するか不明確
   - 実装後に「動かない」ことに気づく

3. **保守性の欠如**
   - UIとロジックの対応関係がコードに散在
   - 変更時に影響範囲が追跡できない

### なぜ今決定が必要か

- 16件の機能実装を開始する前に方針確定が必須
- 「壊れない」ではなく「壊せない」設計が求められる
- 1ヶ月以内の実装完了が目標

---

## 検討した選択肢

### Lv.1：手動ハードコード（失敗済み）

**内容**: Vueに直接 name="total" と手書き

**メリット**:
- 今すぐ書ける
- 追加ツール不要

**デメリット**:
- ❌ タイポが発生
- ❌ Zodとの同期が保証されない
- ❌ IDEが検知できない

**評価**: **絶滅危惧種。二度とやってはいけない**

---

### Lv.2：自動マッピング（鍵リスト）

**内容**: Zodから`keyof().enum`を抽出し、UIの name に紐付け

```typescript
const Keys = ReceiptSchema.keyof().enum;
<input :name="Keys.totalPrice" />
```

**メリット**:
- ✅ タイポが物理的に不可能
- ✅ IDEが即座にエラー検知
- ✅ 導入工数が最小（1日）

**デメリット**:
- ⚠️ 配置作業は手動
- ⚠️ マッピングロジックは別途必要

**評価**: **堅実な一歩。既存コードを活かすならこれ**

---

### Lv.3：静的コード生成（Scribe）

**内容**: Zodを元にAIがVueファイルを自動生成

**メリット**:
- ✅ コードが物理的に存在
- ✅ レスポンシブ調整が容易
- ✅ 再生成で即座に復旧

**デメリット**:
- ⚠️ 生成器の開発が必要
- ⚠️ カスタマイズに制約

**評価**: **目に見える安心。単純な画面に最適**

---

### Lv.4：動的レンダラー（Schema-UI）

**内容**: 1つのコンポーネントがZodを読み込み、勝手に画面を生成

```vue
<Renderer :schema="ReceiptSchema" />
```

**メリット**:
- ✅ スキーマを直すだけで全画面変更
- ✅ 爆速開発

**デメリット**:
- ❌ 例外処理が複雑
- ❌ 特殊なデザイン要求に弱い

**評価**: **爆速開発向け。Kintoneに近い**

---

### Lv.5：意図駆動ハイブリッド（最強）

**内容**: D&Dで配置し、中身の型（鍵）はZodで選択・拘束

**メリット**:
- ✅ UI自由度が最高
- ✅ 型安全性も保証
- ✅ 不整合が即座に検知

**デメリット**:
- ❌ D&Dエディタの開発が必要
- ❌ 開発コストが最高（半年）
- ❌ ツールが存在しない

**評価**: **2026年の理想。ただし今は時期尚早**

---

## 決定内容

### **Lv.2.5：型安全マッピング戦略を採用**

Lv.2をベースに、以下を組み合わせた独自方式：

#### 1. 鍵リスト（Keyof Enum）の全面適用

```typescript
export const Keys = {
  Receipt: ReceiptSchema.keyof().enum,
  Client: ClientSchema.keyof().enum,
  Gemini: GeminiOutputSchema.keyof().enum,
  Yayoi: YayoiSchema.keyof().enum,
};
```

#### 2. 型安全なマッピングオブジェクト

```typescript
const GeminiToYayoiMapping = {
  [GeminiKeys.vendor]: YayoiKeys.vendor_name,
  [GeminiKeys.total]: YayoiKeys.amount,
} as const satisfies Record<GeminiKey, YayoiKey>;
```

#### 3. ロジック・セレクター

```typescript
class LogicSelector {
  selectOCR(name: 'gemini' | 'anthropic');
  selectExport(name: 'yayoi' | 'freee' | 'mf');
  validate(); // 型の整合性を自動チェック
}
```

---

## 根拠

### メリット

| 観点 | 効果 |
|------|------|
| **開発コスト** | 2週間で実装可能（Lv.5は半年） |
| **型安全性** | 完全保証（コンパイル時に検知） |
| **保守性** | マッピング定義が一箇所に集約 |
| **拡張性** | OCR/掃き出しフォーマットの追加が容易 |
| **検証可能性** | 「壊せない」ことをテストで実証可能 |

### デメリットと対策

| デメリット | 対策 |
|-----------|------|
| マッピング定義が手動 | IDEの補完で工数削減 |
| UI配置は手作業 | Lv.3（静的生成）を部分適用 |
| D&Dエディタなし | 将来的にLv.5を検討 |

---

## 実装計画

### Week 1：基盤整備

- [ ] 全Zodから鍵リスト抽出
- [ ] 型安全マッピング雛形の確定
- [ ] ロジック・セレクターの設計

### Week 2：実装

- [ ] マッピング関数の実装
- [ ] ロジック・セレクターの実装
- [ ] 既存画面（1画面）への適用

### Week 3：検証

- [ ] 「壊せなさ」の実証
- [ ] テストコード作成
- [ ] ドキュメント整備

---

## 検証方法

### 「壊せない」ことの実証

1. **タイポテスト**
   - わざと間違ったキー名を書く → コンパイルエラー

2. **型不整合テスト**
   - 互換性のないOCR/掃き出しを組み合わせる → 実行前にエラー

3. **リファクタリングテスト**
   - Zodのフィールド名を変更 → IDEが全箇所を自動修正

---

## 補足情報

### 却下した提案

#### `.describe()`による宣言的マッピング

```typescript
// これは採用しない
z.string().describe("accounting:vendor_name")
```

**理由**:
- 型システム外（文字列なので型チェック不可）
- ツール・AIが無視する可能性
- 構文ミスがコンパイルエラーにならない

**結論**: 主ルートにはしない。UIヒントの補助情報としてのみ使用。

---

## 参考資料

- [DECISION_LOG_20260114.md](../design/DECISION_LOG_20260114.md) - Phase 6判定記録
- [SCHEMA_MASTER_LIST.md](../SCHEMA_MASTER_LIST.md) - 全Zodスキーマ一覧
- Zod公式ドキュメント: https://zod.dev

---

## 変更履歴

| 日付 | 変更内容 | 変更者 |
|------|---------|--------|
| 2026-01-14 | 初版作成 | 司令官 + AI |
