# ADR-002: 段階的UI実装戦略（Screen A First Approach）

**ステータス**: 承認済み  
**決定日**: 2026-01-14  
**決定者**: 司令官  
**関連**: ADR-001（型安全マッピング戦略）

---

## 背景

### 問題の発端

Phase 6完了後、16件のJudgment UseCaseを実装する段階で、以下の課題が明確になった：

1. **過去の失敗パターン**
   - モックUIを先に作成 → 実データ接続時に型不整合 → 大規模な手直し
   - UIとロジックの同時開発 → データフロー不明確 → 迷走

2. **複雑度の問題**
   - Screen E（仕訳入力）は最も複雑な画面
   - AI統合、承認フロー、警告表示など多機能
   - データ契約が確定していない状態での実装はリスクが高い

3. **型安全化の未確立**
   - ADR-001で型安全マッピング（Lv.2.5）を採用したが、UI実装方法は未定義
   - 「UIとロジックを壊さずに実装する手法」が必要

---

## 決定内容

### **段階的UI実装戦略（Screen A First Approach）を採用**

**核心原則**：
1. **シンプルな画面から始める**（Screen A → Screen E）
2. **データ契約を先に確定**（Zodスキーマ → UI Mapper → UI実装）
3. **UI Freezeで型を保護**（確定後は変更禁止）
4. **人間とAIの役割分担を明確化**

---

## 実装手法

### **フェーズ1：Screen A（クライアント一覧）で手法確立**

**選定理由**：
- データ構造がシンプル（`ClientSchema`のみ）
- AI不要（CRUD操作のみ）
- 既に実装済み（改修の影響範囲が明確）
- 失敗しても影響が限定的

**Week 3スケジュール**：

#### **Day 1: データ契約確定**

```typescript
// 1. 既存スキーマの確認
export const ClientSchema = z.object({
  clientCode: z.string(),
  companyName: z.string(),
  // ...
});

// 2. UI表示用スキーマの定義
export const ClientUiSchema = z.object({
  code: z.string(),
  name: z.string(),
  status: z.string(),
  // UI表示に必要なフィールドのみ
});

// 3. Mapperの作成
export const ClientMapper = createMapper(
  ClientSchema,
  ClientUiSchema,
  {
    clientCode: 'code',
    companyName: 'name',
    // ...
  }
);
```

**人間の承認ポイント**：
- ✅ UIに表示すべきフィールドは全て含まれているか？
- ✅ 不要なフィールドは除外されているか？
- ✅ 命名規則は適切か？

---

#### **Day 2-3: UI実装（Mapperベース）**

```typescript
// Ironclad Pattern適用
import { ClientMapper } from '@/composables/ClientMapper';

// Vue Component
const rawData = await getClientsFromFirestore();
const uiData = rawData.map(client => ClientMapper.toUi(client));
// ↑ コンパイル時に型チェック
```

**実装原則**：
1. **Vueコンポーネントは「UIデータ」のみ扱う**
2. **Firestoreデータに直接触らない**
3. **Mapperで型変換を保証**

**AIの役割**：
- UI改修の実装
- 型エラーの検出・修正
- テストコード作成

**人間の役割**：
- UI/UXの判断
- 表示内容の確認
- 動作の承認

---

#### **Day 4: UI Freeze宣言**

```markdown
## UI Freeze宣言（Screen A）

**凍結日**: 2026-01-XX

**凍結対象**：
- [x] ClientUiSchema - UI表示データ
- [x] ClientMapper - データ変換ロジック
- [x] Screen A Layout - 画面レイアウト

**凍結後の変更ルール**：
- ✅ ロジック側での調整：許可
- ❌ UIスキーマの変更：原則禁止
- ❌ Mapperの変更：緊急時のみ、人間承認必須
```

**検証項目**：
- [ ] 全テストがpass
- [ ] 型エラーなし
- [ ] Lintエラーなし
- [ ] モックデータで動作確認
- [ ] 人間が動作を承認

---

#### **Day 5: ドキュメント整備**

- 手法のナレッジ蓄積
- 次画面（Screen E）への適用手順書作成
- ADR更新

---

### **フェーズ2：Screen E（仕訳入力）に適用**

**Week 4以降**：

Screen Aで確立した手法を適用：

```
Day 1-2: データ契約確定
  ↓
Day 3-5: UI実装
  ↓
Day 6: UI Freeze宣言
  ↓
Week 5: AIロジック実装（UIは変更しない）
```

**Screen Eの追加要素**：
- `JobSchema`（Firestore）
- `JobUiSchema`（UI表示）
- `AIProposalSchema`（AI提案）
- `ApprovedJobSchema`（承認後）

**データフロー**：
```
Firestore (Job)
    ↓ JobMapper.toUi()
UI表示 (JobUi)
    ↓ 人間の承認
承認データ (ApprovedJob)
    ↓ JobMapper.toFirestore()
Firestore保存
```

---

## 人間とAI（IDE）の役割分担

### **人間の役割**

| フェーズ | 人間の責任 |
|---------|-----------|
| **データ契約** | スキーマの最終承認、足りないフィールドの指摘 |
| **UI実装** | UI/UXの判断、表示内容の確認、動作承認 |
| **UI Freeze** | Freeze宣言の承認、緊急時の変更判断 |
| **ロジック実装** | AIの提案精度確認、ビジネスルールの指示 |

### **AIの役割**

| フェーズ | AIの責任 |
|---------|---------|
| **データ契約** | 既存スキーマの調査、UiSchemaの提案、Mapper生成 |
| **UI実装** | コード生成、型エラー修正、テスト作成 |
| **検証** | 自動テスト実行、型チェック、Lint実行 |
| **ドキュメント** | ADR作成、手順書作成、ナレッジ蓄積 |

### **自然言語での指示対応**

| 人間の指示（自然語） | AIの行動 |
|-------------------|---------|
| 「クライアント編集機能を追加」 | 1. データ契約確認<br>2. スキーマ提案<br>3. Mapper作成<br>4. UI実装<br>5. テスト作成<br>6. 人間に承認依頼 |
| 「このUIは使いにくい」 | 1. Freezeステータス確認<br>2. Freeze前なら即修正<br>3. Freeze後ならリスク評価<br>4. 修正案を提案 |
| 「AIの提案表示を追加」 | 1. データフロー確認<br>2. 型整合性チェック<br>3. Mapper修正提案<br>4. 実装後に検証 |

---

## 検証プロセス

### **AI（IDE）の自動検証**

```markdown
## 実装時の自動チェック

- [ ] Zodスキーマが存在するか？
- [ ] Mapperが型安全か？
- [ ] UIコンポーネントがMapperを使っているか？
- [ ] 直接Firestoreデータに触っていないか？
- [ ] Ironclad Patternに準拠しているか？

## コミット前の自動チェック

- [ ] 全テストがpass
- [ ] 型エラーなし
- [ ] Lintエラーなし
- [ ] UI Freeze宣言に違反していないか？
```

### **人間の手動検証**

```markdown
## データ契約承認時

- [ ] UIに必要なフィールドが全て含まれているか？
- [ ] 不要なフィールドは除外されているか？
- [ ] 命名規則は理解しやすいか？

## UI実装確認時

- [ ] 画面は使いやすいか？
- [ ] 表示内容は正確か？
- [ ] エラーハンドリングは適切か？

## UI Freeze承認時

- [ ] この状態で確定して良いか？
- [ ] 後から変更が必要になるリスクは？
```

---

## メリット・デメリット

### **メリット**

| 観点 | 効果 |
|------|------|
| **リスク最小化** | 失敗しても影響が限定的（Screen A → Screen E） |
| **手法確立** | シンプルな画面で型安全化パターンを確立 |
| **知見獲得** | Screen Aの経験をScreen Eに活かせる |
| **段階的実装** | 焦らず確実に進められる |
| **検証容易** | シンプルなので検証・テストが容易 |
| **型安全性** | UI Freezeで型を保護、壊せない構造 |

### **デメリットと対策**

| デメリット | 対策 |
|-----------|------|
| 実装時間が長い | Screen Aで手法確立後、Screen Eは高速化 |
| UI Freezeが厳格すぎる | 緊急時の変更手順を明文化 |
| 小さな変更も承認必須 | Freeze前に十分な確認時間を確保 |

---

## UI Freezeの運用ルール

### **Freeze宣言の条件**

1. ✅ Zodスキーマが確定している
2. ✅ Mapperが実装されている
3. ✅ 全テストがpass
4. ✅ モックデータで動作確認済み
5. ✅ 人間が承認している

### **Freeze後の変更手順**

```
緊急変更が必要な場合：

1. 変更理由を文書化
2. 影響範囲を分析（AIが実施）
3. 人間が承認判断
4. 承認後、以下を実施：
   - UI Freeze解除宣言
   - 変更実施
   - テスト実行
   - 再Freeze宣言
```

---

## 成功の測定基準

### **Screen A完了時の達成目標**

- [ ] 型安全化100%（型エラーゼロ）
- [ ] テストカバレッジ80%以上
- [ ] UI Freeze宣言が発行されている
- [ ] 手法ドキュメントが作成されている
- [ ] 人間が「この手法で良い」と承認している

### **Screen E完了時の達成目標**

- [ ] Screen Aと同じ品質基準達成
- [ ] AI統合が型安全に実装されている
- [ ] 承認フローが正常動作
- [ ] CSV出力（ADR-001）と統合されている

---

## 関連資料

- [ADR-001: 型安全マッピング戦略](./ADR-001-type-safe-mapping.md)
- [DECISION_LOG_20260114.md](../design/DECISION_LOG_20260114.md) - Phase 6判定記録
- [Ironclad Architecture](../freeze/README.md) - UI凍結の基本原則

---

## 変更履歴

| 日付 | 変更内容 | 変更者 |
|------|---------|--------|
| 2026-01-14 | 初版作成 | 司令官 + AI |

---

## 補足：経緯と趣旨

### **なぜScreen A Firstか**

過去の開発で「複雑な画面（Screen E）から始めて失敗」した経験から、以下の判断に至った：

1. **シンプルなものから始める**：Screen Aは既存実装があり、データ構造も単純
2. **失敗のコストを最小化**：Screen Aで失敗しても、影響は一覧画面のみ
3. **手法の検証**：型安全化の手法が本当に機能するか、小さく試す
4. **知見の蓄積**：Screen Aでの経験を、より複雑なScreen Eに活かす

### **本質的な目的**

「人間が承認し、自動で記帳できるシステム」を構築すること。

手段（UIの作り方）にこだわらず、目的達成のために最も確実な方法を選択した。

### **AI時代の開発手法**

従来：人間がコードを書く → AIがレビュー  
新手法：人間が自然語で指示 → AIが実装 → 人間が承認

この手法を成功させるためには：
- **データ契約（Zodスキーマ）の明確化**
- **UI Freezeによる型保護**
- **段階的実装によるリスク管理**

が不可欠である。
