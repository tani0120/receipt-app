# UI Freeze Appendix A

: Stress & Boundary Testing Specifications (Ironclad)

## 0. 本文書の位置づけ（絶対）

本書は Phase C（Ironclad Contract）におけるストレステストの完全仕様である。
本書に定義されたテストを 1 つでも省略・簡略化・代替した場合、Phase C は **不合格** とする。

以下を原則とする。
*   **ストレステストは「参考確認」ではなく 合否判定そのもの**
*   **実行されていないテストは 未実施**
*   **証跡（スクリーンショット・ログ）が存在しないテストは 未実施**
*   **「問題が起きなかったから OK」は 理由にならない**

## 1. ストレステストの目的定義

ストレステストの目的は以下の 1 点のみである。
**Contract に基づく防御機構が、想定外・敵対的データに対しても破綻せず、UI が安全であることを証明すること**

以下は目的ではない。
*   見た目が偶然崩れなかったことの確認
*   CSS がたまたま耐えたことの確認
*   人間の目視による「大丈夫そう」という判断

## 2. ストレステストの責務分離

### 2.1 Mapper の責務
*   不正・異常・欠損データを **完全に正規化**
*   UI に **安全な形状のデータのみを渡す**
*   `throw` しない
*   `optional` を残さない

### 2.2 UI の責務
*   **Contract を 信頼する**
*   `if` / `fallback` / 防御ロジックを書かない
*   Mapper が壊れた場合は **ビルド時に壊れる**

## 3. ストレスレベル定義（全段階必須）

| レベル | 内容 | 位置づけ |
| :--- | :--- | :--- |
| **Lv1** | 欠損・null | 最低限 |
| **Lv2** | 想定外コード | 通常異常 |
| **Lv3** | 極端値 | 強 |
| **Lv4** | 敵対的入力 | **最強・必須** |

**Lv4 を含まないテストは、ストレステストと認めない。**

## 4. テスト①：敵対的 API データ生成（Fuzz Input）

### 4.1 原則
*   API は **一切信用しない**
*   「あり得ない」を **意図的に生成する**
*   全フィールドに対して適用する

### 4.2 型破壊（必須）
以下を **全項目に対して個別に実施する**。

*   **数値フィールド**
    *   `"NaN"`
    *   `"∞"`
    *   `"Infinity"`
    *   `"123abc"`
    *   `999999999999999999999999`
    *   `-999999999999999999999999`
*   **文字列フィールド**
    *   `0`
    *   `1`
    *   `true`
    *   `false`
    *   `null`
    *   `undefined`
    *   `{}`
*   **boolean フィールド**
    *   `"true"`
    *   `"false"`
    *   `1`
    *   `0`
    *   `null`
    *   `"yes"`

### 4.3 欠損・構造破壊（必須）
*   `key` 自体を削除
*   `undefined` / `null` 混在
*   空オブジェクト `{}` を丸ごと渡す
*   配列の中身を `{}` にする

### 4.4 異常文字（必須）
*   改行 `\n`
*   制御文字 `\u0000`
*   タブ `\t`
*   絵文字（複数連続）
*   全角・半角混在
*   RTL（右から左）文字列

### 4.5 長さ攻撃（最重要）
以下を **必ず全項目で実施する**。
*   10,000 文字
*   50,000 文字
*   改行なし・スペースなし連続文字
*   英数字のみ
*   日本語のみ

## 5. テスト②：Mapper 単体破壊テスト（最重要）

### 5.1 目的
UI を介さず、Mapper 単体を壊しに行く

### 5.2 必須条件
Mapper は以下を **すべて満たすこと**
*   `throw` しない
*   `return` が **必ず UI Contract 型**
*   `optional` が残らない
*   `null` / `undefined` を含まない
*   型が `string` / `number` に正規化されている

### 5.3 推奨テスト形式（例）
```typescript
for (const evilInput of evilApiSamples) {
  const ui = mapApiToUi(evilInput)
  assert(isValidUiContract(ui))
}
```

### 5.4 判定
*   1 ケースでも失敗 → **Phase C 不合格**
*   `try-catch` で握り潰した場合 → **不合格**

## 6. テスト③：UI 白化テスト（Visual Kill Test）

### 6.1 方法
*   Mapper の出力を **そのまま UI に流す**
*   `v-for` 等で 100 件以上描画
*   スクロール・リサイズを実施

### 6.2 判定基準（すべて必須）
*   **UI が真っ白にならない**
*   画面全体が描画され続ける
*   コンソールエラー 0
*   レイアウト崩壊なし
*   横スクロール発生なし

## 7. テスト④：レイアウト耐性テスト（CSS Kill）

### 7.1 入力条件
*   寿限無 10,000 文字
*   改行なし
*   英数字のみ
*   日本語のみ

### 7.2 必須 CSS 対応
*   `break-all`
*   `min-h`
*   `overflow-hidden`
*   `truncate`（必要箇所）

### 7.3 判定
*   CSS が Mapper 防御を補完していること
*   **1 箇所でもレイアウト破壊 → 不合格**

## 8. テスト⑤：Contract 破壊テスト（思想的・必須）

### 8.1 方法
意図的に UI 側で Contract を破る。
例：
```typescript
job.clientName as any
job.status!.label
```

### 8.2 期待結果
*   TypeScript がエラー
*   UI 実装が **ビルド時に停止**

### 8.3 判定
*   実行時エラーで壊れる → **失敗**
*   `any` で通る → **失敗**

## 9. テスト⑥：Snapshot / Visual Regression

### 9.1 必須成果物
*   `stress_worst.png`（Lv4）
*   `stress_longtext.png`（長文攻撃）

### 9.2 要件
*   Freeze フォルダに保存
*   撮影日時・Commit Hash が README に記載されていること
*   **事後撮影は 無効**

## 10. 最終合格条件（Ironclad 判定）

以下 **すべて Yes の場合のみ合格**。
*   [ ] Mapper が `throw` しない
*   [ ] UI が白くならない
*   [ ] Contract が破れない
*   [ ] レイアウトが崩れない
*   [ ] コンソールエラー 0
*   [ ] 視覚差分が説明可能
*   [ ] 全証跡が存在

## 11. 不合格時の扱い
*   Phase C 未完
*   Freeze 不成立
*   **再実施必須（事後補完不可）**
